Procedure init(G:Graph, parent:N_P<Node>, id:N_P<Long>, pid:N_P<Long>)
{
    Foreach(n: G.Nodes){
        Foreach(in: n.Nbrs){
            <n.pid;n.parent> min= <in.id;in>;
        }
    }
    Foreach(n:G.Nodes){
        If(n.pid >= n.id)
	        n.parent = n;
    }
}
//due to the mistake in paper, this function "correct" the first step. Make it same as Figure2 in paper.
Procedure mistake(G:Graph, parent:N_P<Node>, id:N_P<Long>, pid:N_P<Long>){
    Foreach(n:G.Nodes){
	    Foreach(t:G.Nodes){
	        If(n.id==12 && t.id == 10){
		        n.pid = 10;
	                n.parent = t;
	        }
	    }
    }
}

Procedure singleton_elimination(G: Graph, size:Long, parent:N_P<Node>, id:N_P<Long>,pid:N_P<Long>,count:N_P<Int>){
    Foreach(n:G.Nodes){
        Foreach(e: n.Nbrs){
	        If(e.pid == n.id){
		        n.count += 1;
	        }
	    }
    }
    Foreach(n:G.Nodes){
	    Long mmin = size;
	    Node nn;
	    Int flag = 0;
        If(n.count ==0 && n.pid == n.id){
	        Foreach(e:n.Nbrs){
	            <mmin;nn> min= <e.id;e>;
    	        flag = 1;
	        }
	        If(flag == 1){
		        n.pid = mmin;
		        n.parent = nn;
	        }
	    }
    }
}
Procedure star_detection(G: Graph, parent:N_P<Node>,id:N_P<Long>,pid:N_P<Long>,star:N_P<Int>):Long{
    Long ret = 0;
    Foreach(n:G.Nodes){
        n.star = 1;
    }
    //rule 1
    Foreach(n:G.Nodes){
        Node fa = n.parent;
	    If(fa.pid != n.pid){
	        n.star = 0;
	    }
    }
    //rule 2
    Foreach(n:G.Nodes){
	    If(n.star == 0){
           //shit grammar!
	        Node fa = n.parent;
	        Node gf = fa.parent;
	        gf.star = 0;
	    }
    }
    //rule 3
    Foreach(n:G.Nodes){
	    Node fa = n.parent;
	    If(fa.star == 0)
	        n.star = 0;
    }
    Foreach(n:G.Nodes){
            If(n.star == 1)
                ret += 1;
    }
    Return ret;
}
Procedure C_star_hooking(G: Graph, size:Long,parent:N_P<Node>,id:N_P<Long>,pid:N_P<Long>,star:N_P<Int>):Int{
     Int ret = 0;
     Foreach(n:G.Nodes){
	    If(n.star == 1 && n.pid != n.id){
	        Long minPid = size+1;
	        Node minNode;
	        Node fa1 = n.parent;
	        Foreach(t:n.Nbrs)(t.star == 1){
		        Node ff = t.parent;
		        <minPid;minNode> min= <ff.id;ff.parent>;
	        }
	   //if fa1 hooked to fa2, then 2 tree should be set to star 
	        If(fa1.id > minPid){
                        ret++;
		        fa1.parent = minNode;
		        fa1.pid = minPid;
		        Node fa2 = minNode;
		       // fa1.star = 0;
		       // Foreach(f1:fa1.Nbrs){
		       //     If(f1.pid == fa1.id)
			//        f1.star = 0;
		        //}
		       // If(fa2.star == 1){
		         //   fa2.star = 0;
		           // Foreach(f2:fa2.Nbrs){
			      //      f2.star = 0;
		            //}
		        //}
	        }
	    }
    }
    Return ret;
}
Procedure U_star_hooking(G: Graph,size: Long, parent:N_P<Node>,id:N_P<Long>,pid:N_P<Long>,star:N_P<Int>):Int{
    Int ret = 0;
    Foreach(n:G.Nodes){
        If(n.star == 1 && n.pid != n.id){
            Long minPid = size+1;
            Node minNode;
            Node fa1 = n.parent;
	        Int flag = 0;
            Foreach(t:n.Nbrs)(t.pid!=n.pid){
		        flag = 1;
                Node ff = t.parent;
                <minPid;minNode> min= <ff.id;ff>;
            }

            If(flag == 1){
            //if fa1 hooked to fa2, then 2 tree should be set to star
                ret++;
		fa1.parent = minNode;
                fa1.pid = minPid;
                Node fa2 = minNode;
               // fa1.star = 0;
                //Foreach(f1:fa1.Nbrs){
                  //  If(f1.pid == fa1.id)
                    //    f1.star = 0;
                //}
               // If(fa2.star == 1){
                 //   fa2.star = 0;
                   // Foreach(f2:fa2.Nbrs){
                     //   f2.star = 0;
                    //}
                //}
            }
        }
    }
    Return ret;
}
Procedure pointer_jumping(G:Graph,parent:N_P<Node>,id:N_P<Long>,pid:N_P<Long>){
     N_P<Long> parId;
     N_P<Node> parNode;
     Map<Long,Node> IdNode;
     Foreach(n:G.Nodes){
         n.parId = n.pid;
         n.parNode = n.parent;
         IdNode[n.id] = n;
     }
     Foreach(n:G.Nodes){
         Node fn = n.parNode;
         Long fid = fn.id;
         Long gid = fn.parId;
         n.pid = gid;
     }
     Foreach(n:G.Nodes){
         Long fid = n.pid;
         n.parent = IdNode[fid];
     }
}
Procedure ret_cc_num(G:Graph,id:N_P<Long>,pid:N_P<Long>):Long{
    Long rett = 0;
    Foreach(n:G.Nodes){
	If(n.id == n.pid)
	    rett++;
    }
    Return rett;      
}
