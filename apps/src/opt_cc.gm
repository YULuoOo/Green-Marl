Procedure opt_cc(G:Graph, size:Long, parent:N_P<Node>,id:N_P<Long>,pid:N_P<Long>,star:N_P<Int>,count:N_P<Int>):Long{
    //init
    N_P<Long> parId;
    N_P<Node> parNode;
    Foreach(n: G.Nodes){
        Foreach(in: n.Nbrs){
            <n.pid;n.parent> min= <in.id;in>;
        }
    }
    Foreach(n:G.Nodes){
        If(n.pid >= n.id)
            n.parent = n;
    }

    //singleton_elimination(G,size,parent,id,pid,count);
     Foreach(n:G.Nodes){
        Foreach(e: n.Nbrs){
            If(e.pid == n.id){
                n.count += 1;
            }
        }
    }
    Foreach(n:G.Nodes){
        Long mmin = size;
        Node nn;
        Int flag = 0;
        If(n.count ==0 && n.pid == n.id){
            Foreach(e:n.Nbrs){
                <mmin;nn> min= <e.id;e>;
                flag = 1;
            }
            If(flag == 1){
                n.pid = mmin;
                n.parent = nn;
            }
        }
    }
    G.count = 0;
    Foreach(n:G.Nodes){
        Foreach(e: n.Nbrs){
            n.count += 1;
        }
    }

    //Long ret1 = star_detection(G,parent,id,pid,star,count);
    Long ret1 = 0;
    G.star = 1;
    //rule 1
    Foreach(n:G.Nodes)(n.count != 0){
        Node fa = n.parent;
        If(fa.pid != n.pid){
            n.star = 0;
        }
    }
    //rule 2
    Foreach(n:G.Nodes)(n.count != 0){
        If(n.star == 0){
           //shit grammar!
            Node fa = n.parent;
            Node gf = fa.parent;
            gf.star = 0;
        }
    }
    //rule 3
    Foreach(n:G.Nodes)(n.count != 0){
        Node fa = n.parent;
        If(fa.star == 0)
            n.star = 0;
    }
    Foreach(n:G.Nodes){
            If(n.star == 1)
                ret1 += 1;
    }
    Int ii = 0;
    Int hookingRet1 = 0;
    Int hookingRet2 = 0;
    While(ret1 != size || hookingRet1 != 0 || hookingRet2 != 0){
        //hookingRet1 =  C_star_hooking(G,size,parent,id,pid,star,count);
         hookingRet1 = 0;
           Foreach(n:G.Nodes)(n.star==1 && n.pid == n.id && n.count!=0){
                   Long minPPid = size+1;
                   Node minNNode = n;
                   Long minPid2 = size+1;
                   Node minNode2 = n;
                   InBFS(e:G.Nodes From n)[e.pid == n.id]{
                       Foreach(t:e.Nbrs)(t.pid < n.id){
                           <minPPid;minNNode> min= <t.pid;t.parent>;
                       }
                   }
                   Foreach(t:n.Nbrs)(t.pid < n.id){
                        <minPid2;minNode2> min= <t.pid;t.parent>;
                   }
                   If(minPPid>minPid2){
                       minPPid = minPid2;
                       minNNode = minNode2;
                   }
                 If(n.id > minPPid){
                         hookingRet1++;
                         n.parent = minNNode;
                         n.pid = minPPid;
                 }
            }

        //star_detection(G,parent,id,pid,star,count);
        G.star = 1;
        //rule 1
        Foreach(n:G.Nodes)(n.count != 0){
            Node fa = n.parent;
            If(fa.pid != n.pid){
                n.star = 0;
            }
        }
        //rule 2
        Foreach(n:G.Nodes)(n.count != 0){
            If(n.star == 0){
               //shit grammar!
                Node fa = n.parent;
                Node gf = fa.parent;
                gf.star = 0;
            }
        }
        //rule 3
        Foreach(n:G.Nodes)(n.count != 0){
            Node fa = n.parent;
            If(fa.star == 0)
                n.star = 0;
        }

        //hookingRet2 = U_star_hooking(G,size,parent,id,pid,star,count);
        hookingRet2 = 0;
           Foreach(n:G.Nodes)(n.star==1 && n.pid == n.id && n.count!=0){
                  Long minPPid = size+1;
                  Node minNNode;
                  Long minPid2 = size+1;
                  Node minNode2;
                  InBFS(e:G.Nodes From n)[e.pid == n.id]{
                       Foreach(t:e.Nbrs)(t.pid < n.id){
                           <minPPid;minNNode> min= <t.pid;t.parent>;
                       }
                   }
                   Foreach(t:n.Nbrs)(t.pid < n.id){
                        <minPid2;minNode2> min= <t.pid;t.parent>;
                   }
                   If(minPPid>minPid2){
                       minPPid = minPid2;
                       minNNode = minNode2;
                   }
                If(minPPid != size+1 && minPPid != n.pid){
                   hookingRet2++;
                   n.parent = minNNode;
                   n.pid = minPPid;
               }
           }

        //ret1 = star_detection(G,parent,id,pid,star,count);
        ret1 = 0;
        G.star = 1;
        //rule 1
        Foreach(n:G.Nodes)(n.count != 0){
            Node fa = n.parent;
            If(fa.pid != n.pid){
                n.star = 0;
            }
        }
        //rule 2
        Foreach(n:G.Nodes)(n.count != 0){
            If(n.star == 0){
               //shit grammar!
                Node fa = n.parent;
                Node gf = fa.parent;
                gf.star = 0;
            }
        }
        //rule 3
        Foreach(n:G.Nodes)(n.count != 0){
            Node fa = n.parent;
            If(fa.star == 0)
                n.star = 0;
        }
        Foreach(n:G.Nodes){
                If(n.star == 1)
                    ret1 += 1;
        }

        //pointer_jumping(G,parent,id,pid,star,count);
         Map<Long,Node> IdNode;
         Foreach(n:G.Nodes)(n.count!=0 && n.star == 0){
             n.parId = n.pid;
             n.parNode = n.parent;
             IdNode[n.id] = n;
         }
         Foreach(n:G.Nodes)(n.count!=0 && n.star == 0){
             Node fn = n.parNode;
             n.pid = fn.parId;
             n.parent = fn.parNode;
         }
         Foreach(n:G.Nodes){
              Long fid = n.pid;
              n.parent = IdNode[fid];
          }

        //star_detection(G,parent,id,pid,star,count);
        G.star = 1;
        //rule 1
        Foreach(n:G.Nodes)(n.count != 0){
            Node fa = n.parent;
            If(fa.pid != n.pid){
                n.star = 0;
            }
        }
        //rule 2
        Foreach(n:G.Nodes)(n.count != 0){
            If(n.star == 0){
               //shit grammar!
                Node fa = n.parent;
                Node gf = fa.parent;
                gf.star = 0;
            }
        }
        //rule 3
        Foreach(n:G.Nodes)(n.count != 0){
            Node fa = n.parent;
            If(fa.star == 0)
                n.star = 0;
        }
    }
    Long rett = 0;
    Foreach(n:G.Nodes){
    If(n.id == n.pid)
        rett++;
    }
    Return rett;
}
