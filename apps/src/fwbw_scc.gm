Proc color_scc(G:Graph,color:N_P<Int>,id:N_P<Int>,scc:N_P<Int>,size:Int):Int{
    Int i = 0;
    Int nnum = size;
    Int ret = 0;
    Int change = 1;
    N_P<Int> temp;
    N_P<Int> color2;
    N_P<Bool> used;
    G.used = False;
    G.temp = -1;
    G.color2 = -1;
    Int x = 0;

    While(nnum > 0){
        [printf("round %d\n", i)];
        i++;
        x = 0;
        nnum=0;
        Foreach(n:G.Nodes)(n.used == False){
            n.color = n.id;
        }
        While(change > 0){
            change = 0;
            Foreach(n:G.Nodes)(n.used == False){
                Foreach(e:n.OutNbrs)(n.used == False){
                    If(n.color < e.color){
                        e.color2 = n.color;
                        change++;
                    }
                }
            }
            Foreach(n:G.Nodes)(n.color2 != -1 && n.used == False){
                n.color = n.color2;
                n.color2 = -1;
            }
        }
        [printf("step 1 over \n")];
        Foreach(n:G.Nodes)(n.used == False && n.color == n.id){
            n.scc = n.id;
        }
        Foreach(n:G.Nodes)(n.used == False){
            x++;
        }

        [printf("still have %d \n",x)];
        change = 1;
        While(change > 0){
            change = 0;
            Foreach(n:G.Nodes)(n.scc == n.color && n.used == False){
                n.temp = n.scc;
                change++;
                Foreach(e:n.InNbrs)(e.color == n.color && e.scc == -1 && n.used == False){
                    e.temp = n.scc;
                    change++;
                }
            }
            Foreach(n:G.Nodes)(n.temp != -1 && n.used == False){
                n.scc = n.temp;
                n.used = True;
                n.temp = -1;
            }
        }

        [printf("step 2 over \n")];
        Foreach(n:G.Nodes)(n.used == False){
            nnum++;
        }
        [printf("still have %d \n",nnum)];
        change = 1;

    }
    Foreach(n:G.Nodes)(n.scc == n.id){
        ret++;
    }
    Return ret;
}